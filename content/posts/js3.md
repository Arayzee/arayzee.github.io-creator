---
title: "JS函数执行时机"
date: 2020-04-13T22:08:11+08:00
categories: ["前端"]
tags: ["JS", "tech"]
draft: false
---

观察以下代码：
```javascript
let i = 0
for(i = 0; i<6; i++){
  setTimeout(()=>{
    console.log(i)
  },0)
}
```
大多数人凭借直觉可能会觉得打印结果为`0, 1, 2, 3, 4, 5`，`setTimeout(()=>{console.log(i)},0)`仿佛和直接执行没有区别。然而事实上这段代码的打印结果为`6, 6, 6, 6, 6, 6`，setTimeout函数会将回调函数加入任务队列，即使延时是0ms，只有把当前队列中的任务执行完才会调用setTimeout函数内的回调函数。在此例中，当前任务为for循环，当i = 6时，for循环结束，此时开始依次执行6次`console.log(i)`,所以打印结果为`6, 6, 6, 6, 6, 6`。

那么如何才能让上述代码打印出`0, 1, 2, 3, 4, 5`呢？

### 方法1
```javascript
for(let i = 0; i<6; i++){
  setTimeout(()=>{
    console.log(i)
  },0)
}
```
仅仅是把let放入for循环里面，就得到了我们想要的`0, 1, 2, 3, 4, 5`。看起来匪夷所思，其实是JS在这里做了手脚，当for与let组合时，JS会为每一次循环创建一个循环变量，所以这段代码实际上产生了7个i。JS为了迎合人们的直觉做出这种反逻辑的修改实在是令人困惑，也难怪被这么多人诟病。

### 方法2
```javascript
let i = 0
for(i = 0; i<6; i++){
  ! function(i) {
    setTimeout(()=>{
      console.log(i)i
    },0)
  } (i)
}
```
在这个方法中，我们在每个循环内把当前i的值传入一个立即执行函数中作为局部变量记录下来，所以我们打印的i其实是每个立即执行函数中记录了当时传入值的局部变量i，得到了`0, 1, 2, 3, 4, 5`的结果。